# Component Extraction Feature

## Overview

The Component Extraction feature automatically detects repeating UI patterns in generated layouts and allows users to extract them into reusable React components.

## How It Works

### 1. Pattern Detection (Clustering)

The system analyzes the layout JSON produced by the Layout Analyzer stage to find repeated structures:

**Heuristics Used:**
- **Same Tag/Type**: Elements must have the same `type` (e.g., `card`, `button`)
- **Similar Child Count**: Elements with the same number of children are grouped
- **Similar Layout**: Elements with the same `layout` property (row, column, grid)
- **Shared Structure**: Elements with similar child type compositions

**Similarity Threshold:** 70% (configurable)

**Algorithm:**
1. Flatten the layout tree into a node map
2. Generate structural fingerprints for each node
3. Group nodes by fingerprint
4. Refine clusters using pairwise similarity scoring
5. Filter clusters with at least 2 instances

### 2. Prop Inference

For each detected cluster, the system infers props from the element structure:

| Element Type | Inferred Prop | Prop Type |
|-------------|---------------|-----------|
| Text with `textRole: title` | `title` | `text` |
| Text with `textRole: subtitle` | `subtitle` | `text` |
| Text with `textRole: body` | `body` | `text` |
| `type: image` | `imageSrc` | `image` |
| `type: avatar` | `avatarSrc` | `image` |
| `type: button/link` | `href`, `label` | `href`, `text` |
| Element with `icon` property | `icon` | `icon` |

### 3. Component Generation

When the user confirms extraction, the system generates:

**Component File (`src/components/Extracted/<ComponentName>.tsx`):**
```tsx
// Generated by NEURON: Component extracted from node n-13
// Cluster contains 3 instances

import React from 'react';

interface FeatureCardProps {
  title: string;
  body: string;
  icon: string;
}

export default function FeatureCard({ 
  title = "Feature One",
  body = "Description goes here.",
  icon = "star"
}: FeatureCardProps) {
  return (
    <article className="flex flex-col gap-4 p-6 rounded-lg border bg-card">
      <span>{icon}</span>
      <h3>{title}</h3>
      <p>{body}</p>
    </article>
  );
}

export { FeatureCard };
```

**Replacements:**
Each instance in the original code is replaced with component usage:
```tsx
// Before:
<div class="card">
  <span>⭐</span>
  <h3>Feature One</h3>
  <p>Description...</p>
</div>

// After:
<FeatureCard title="Feature One" body="Description..." icon="star" />
```

## File Storage

Generated component files are stored in:
```
projects/<projectId>/src/components/Extracted/
├── FeatureCard.tsx
├── TestimonialCard.tsx
└── ...
```

## API Endpoints

### GET `/api/project/:id/extract-candidates`

Find extraction candidates for a project.

**Query Parameters:**
- `node` (optional): Specific node ID to find clusters for

**Response:**
```json
{
  "success": true,
  "data": {
    "projectId": "abc123",
    "clusters": [
      {
        "clusterId": "cluster-xyz",
        "sampleNodeId": "feature-card-1",
        "instances": ["feature-card-1", "feature-card-2", "feature-card-3"],
        "instanceCount": 3,
        "similarity": 0.85,
        "suggestedName": "FeatureCard",
        "propCandidates": [
          { "name": "title", "type": "text", "sampleValue": "Feature One" }
        ]
      }
    ]
  }
}
```

### POST `/api/project/:id/extract-component`

Generate extraction patch (does not apply).

**Request Body:**
```json
{
  "elementId": "feature-card-1",
  "componentName": "FeatureCard",
  "clusterId": "cluster-xyz"
}
```

**Response:**
```json
{
  "success": true,
  "data": {
    "patch": {
      "componentName": "FeatureCard",
      "files": [{ "path": "...", "content": "...", "language": "tsx" }],
      "replacements": [...],
      "diff": { "before": "...", "after": "..." }
    }
  }
}
```

### POST `/api/project/:id/apply-extraction`

Apply the extraction patch.

**Request Body:**
```json
{
  "patch": { ... }
}
```

### POST `/api/project/:id/revert-extraction`

Revert an extraction.

**Request Body:**
```json
{
  "versionId": 0
}
```

## UI Integration

### Inspector Panel

When a user selects an element in the Inspector, if that element is part of a repeating cluster, an "Extract as Component" button appears.

### Extraction Modal

The modal shows:
1. **Component Name Input**: Editable, pre-filled with suggested name
2. **Cluster Info**: Number of instances, similarity score
3. **Detected Props**: List of inferred props with types
4. **Diff Preview**: Before/after comparison
5. **Action Buttons**: Preview, Apply Patch, Revert

### Post-Extraction

After successful extraction:
- Toast notification confirms success
- New component file appears in editor tabs
- "Revert" option available in modal or toast

## Reverting Extractions

Extractions can be reverted if:
1. It's the most recent active extraction
2. Original code was saved in version history

**Process:**
1. Click "Revert" in the modal or toast
2. System restores original code
3. Generated files are marked as unused
4. Extraction entry marked as "reverted" in history

## Running Tests

```bash
# Run all extraction tests
cd apps/api
npx vitest run extract_components.test.ts

# Run with watch mode
npx vitest watch extract_components.test.ts

# Run specific test
npx vitest run -t "should find repeated card structures"
```

## Database Schema

The feature adds two fields to the `Project` model:

```prisma
model Project {
  // ... existing fields ...
  
  // Layout analysis output (JSON)
  layoutJson String?
  
  // Extraction version history (JSON)
  extractionHistory String?
}
```

## Configuration

No additional configuration required. The feature uses existing AI providers and follows project-level settings for TypeScript/JavaScript output.

## Limitations

1. **AST Transforms**: Current implementation uses string-based replacements. For production, consider using Babel/TypeScript AST transforms.

2. **Nested Components**: The system extracts top-level repeating patterns. Deeply nested repeating elements may not be detected.

3. **Dynamic Content**: Components with dynamic content (loops, conditionals) require manual prop mapping.

4. **Style Extraction**: Tailwind classes are copied as-is. Custom CSS may need manual adjustment.

## Future Enhancements

- [ ] AST-based code transformation
- [ ] Nested component detection
- [ ] Auto-import in parent component
- [ ] Style token extraction
- [ ] Component variants generation
- [ ] TypeScript strict mode support
